## 참고
    https://hyperledger-fabric.readthedocs.io/en/latest/txflow.html
    
## Trasaction Flow

    이 문서는 표준 자산 교환 중에 발생하는 트랜잭션 메커니즘을 설명합니다. 시나리오에는 무를 사고 파는 
    두 명의 고객 A와 B가 포함됩니다. 그들은 각각 네트워크를 통해 거래를 보내고 원장과 상호 작용하는 동료를가집니다
    
### Assumptions (가정)

    이 플로우는 채널이 설정되어 실행 중이라고 가정합니다. 응용 프로그램 사용자는 조직의 CA (Certificate Authority)에 등록 및 등록하고 네트워크에 인증하는 데 
    필요한 필수 암호화 자료를 다시 수신합니다
    
    체인 코드는(무의 초기 상태를 나타내는 일련의 키 값 쌍을 포함) 피어에 설치되고 채널에서 인스턴스화됩니다.
    
    체인 코드는 일련의 거래 지시와 무에 대해 합의 된 가격을 정의하는 로직을 포함합니다. 이 체인 코드에 대한 보증 정책이 설정되어있어 peerA와 peerB가 트랜잭션을 보증해야한다는 것을 나타냅니다
    
    
### 1. Client A initiates a transaction
    
    무슨 일이야? - 고객 A가 무를 구입하라는 요청을 보냈습니다. 요청은 각각 클라이언트 A와 클라이언트 B를 대표하는 peerA와 peerB를 대상으로합니다. 
    (endorsement policy)보증 정책은 두 피어가 모든 트랜잭션을 보증해야한다는 것을 나타내므로 요청은 peerA와 peerB로 이동합니다
    
    다음으로 거래 제안서가 작성됩니다. 지원되는 SDK (Node, Java, Python)를 활용하는 응용 프로그램은 트랜잭션 제안서를 생성하는 사용 가능한 API 중 하나를 사용합니다. 
    이 제안은 체인 코드 기능을 호출하여 데이터를 판독기에 쓰거나 쓰기 (즉, 자산에 대한 새로운 키 값 쌍 작성) 할 수 있도록하는 요청입니다. 
    SDK는 트랜잭션 제안서를 구조화 된 형식 (gRPC를 통한 프로토콜 버퍼)으로 패키지화하기위한 shim 역할을하며 사용자의 암호화 자격 증명을 사용하여이 
    트랜잭션 제안서의 고유 한 서명을 생성합니다.
    
### 2. Endorsing peers verify signature & execute the transaction (피어를 인증하고 트랜잭션을 실행하는 것을 보증하는 피어)

    (1) 거래 제안서가 잘 형성되었는지, (2) 과거에 제출되지 않았는지 (재생 공격 보호), (3) 서명이 유효한지 (MSP 사용), (4) 제출자 (예 : 클라이언트 A)가 
    해당 채널에서 제안 된 작업을 수행 할 수 있도록 적절한 권한을 부여 받았음을 나타냅니다 (즉, 각 인증 피어는 제출자가 채널의 작성자 정책을 충족하는지 확인합니다). 
    보증 피어는 호출 된 체인 코드의 함수에 대한 인수로 트랜잭션 제안 입력을받습니다. 
    체인 코드는 현재 상태 데이터베이스에 대해 실행되어 응답 값, 읽기 세트 및 쓰기 세트를 포함하는 트랜잭션 결과를 생성합니다. 이 시점에서 원장 갱신은 이루어지지 않습니다. 
    이 값들의 집합은 승인 피어의 서명과 함께 응용 프로그램이 소비 할 페이로드를 파싱하는 SDK에 "제안 응답"으로 다시 전달됩니다
    
    - note
    MSP는 피어가 클라이언트에서 도착한 트랜잭션 요청을 확인하고 트랜잭션 결과 (보증)에 서명 할 수있게하는 피어 구성 요소입니다. 
    쓰기 정책은 채널 생성시 정의되며 해당 채널에 트랜잭션을 제출할 수있는 사용자를 결정합니다
    
### 3. Proposal responses are inspected (제안 응답을 검사합니다.)

    응용 프로그램은 승인 피어 서명을 확인하고 제안 응답을 비교하여 제안 응답이 동일한 지 확인합니다. 
    체인 코드가 원장에게만 쿼리 한 경우 응용 프로그램은 쿼리 응답을 검사하여 대개 주문 트랜잭션에 트랜잭션을 제출하지 않습니다. 
    클라이언트 애플리케이션이 거래를 주문 서비스에 제출하여 원장을 업데이트하려는 경우, 
    애플리케이션은 제출하기 전에 지정된 보증 정책이 충족되었는지 (즉, peerA 및 peerB 모두 보증했는지)를 결정합니다. 
    응용 프로그램이 응답을 검사하지 않거나 처리되지 않은 트랜잭션을 전달하지 않더라도 응용 프로그램이 피어에 의해 시행되고 커밋 유효성 검사 단계에서지지되도록 아키텍처가 구성됩니다.
    
### 4. Client assembles endorsements into a transaction(클라이언트가 보증을 트랜잭션으로 합칩니다.)

    응용 프로그램은 "거래 메시지"내의 거래 제안서와 응답을 주문 서비스에 "방송"합니다. 트랜잭션에는 읽기 / 쓰기 세트, 승인 피어 서명 및 채널 ID가 포함됩니다. 
    Ordering Service는 트랜잭션을 수행하기 위해 트랜잭션의 전체 내용을 검사 할 필요가 없으며 네트워크의 모든 채널에서 트랜잭션을 수신하고 채널별로 
    시간순으로 정렬하며 채널당 트랜잭션 블록을 생성합니다
    
    
### 5.Transaction is validated and committed ( 트랜잭션 확인되고 커밋됨)

    거래 블록은 채널의 모든 피어에게 전달됩니다. 블록 내의 트랜잭션은 보증 정책이 충족되고 트랜잭션 집합에 의해 읽기 집합이 생성 되었기 때문에 읽기 집합 변수에 대한 원장 
    상태가 변경되지 않았는지 확인하기 위해 유효성이 검사됩니다. 
    블록의 트랜잭션은 유효하거나 유효하지 않은 것으로 태그가 지정됩니다
    
### 6. Ledger updated

    각 피어는 블록을 채널의 체인에 추가하고 유효한 트랜잭션마다 쓰기 세트가 현재 상태 데이터베이스에 커밋됩니다. 
    클라이언트 응용 프로그램에 트랜잭션 (호출)이 체인에 영구적으로 추가되었음을 알리는 이벤트와 트랜잭션이 유효한지 유효하지 않은지 여부에 대한 알림이 생성됩니다
    