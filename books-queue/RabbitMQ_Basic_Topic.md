### Topic (https://www.rabbitmq.com/tutorials/tutorial-five-java.html)

    이전 튜토리얼에서는 로깅 시스템을 개선했습니다. dummy broadcasting 만 가능한 fanout 교환 대신에 우리는 direct broadcasting을 
    사용하여 선택적으로 로그를 수신 할 수있었습니다
    
    직접 교환을 사용하면 시스템이 개선되었지만 여전히 여러 가지 기준에 따라 라우팅을 수행 할 수 없습니다
    
    로깅 시스템에서는 심각도를 기반으로 로그뿐만 아니라 로그를 생성 한 소스를 기반으로 로그를 구독하고자 할 수 있습니다. 
    심각도 (info / warn / crit ...)와 facility (auth / cron / kern ...)를 기반으로 
    로그를 라우팅하는 syslog unix 도구에서이 개념을 알 수 있습니다
    
    그것은 우리에게 많은 유연성을 줄 것입니다. 우리는 'cron'에서 오는 중요한 오류뿐만 아니라 'kern'의 모든 로그도들을 수 있습니다.
    
    로깅 시스템에서이를 구현하려면보다 복잡한 topic exchange에 대해 알아야합니다.
    
#### Topic exchange

    주제 교환에 전송 된 메시지에는 임의의 routing_key가있을 수 없습니다. 점으로 구분 된 단어 목록이어야합니다. 
    단어는 무엇이든 가능하지만 일반적으로 메시지에 연결된 일부 기능을 지정합니다. 
    몇 가지 유효한 라우팅 키 예 : "stock.usd.nyse", "nyse.vmw", "quick.orange.rabbit". 
    라우팅 키에는 원하는만큼 많은 단어가있을 수 있습니다 (최대 255 바이트까지 가능).
    
    바인딩 키는 동일한 양식이어야합니다. 
    topic exchange 의 논리는 direct routing과 유사합니다. 
    특정 라우팅 키와 함께 전송 된 메시지는 일치하는 바인딩 키로 바인드 된 모든 queue에 전달됩니다. 
    그러나 바인딩 키에는 중요한 두 가지 중요한 경우가 있습니다.
    
    * (별표)는 정확히 한 단어를 대신 할 수 있습니다.
    # (해시)는 0 개 이상의 단어를 대체 할 수 있습니다.
    
    이 예에서는 동물을 묘사하는 메시지를 보내 게됩니다. 
    메시지는 세 단어 (두 개의 점)로 구성된 라우팅 키와 함께 전송됩니다. 
    라우팅 키의 첫 번째 단어는 속도, 두 번째 색 및 세 번째 종을 나타냅니다. "<speed>. <color>. <species>".
    
    우리는 세 가지 바인딩을 만들었습니다. Q1은 바인딩 키 "* .orange. *"로 바인딩되고 Q2는 "*. *. rabbit"및 "lazy. #"로 바인딩됩니다.
    
    이러한 바인딩은 다음과 같이 요약 할 수 있습니다.
    
    Q1은 모든 주황색 동물에 관심이 있습니다.
    Q2는 토끼와 게으른 동물에 관한 모든 것을 듣고 싶어합니다.
    
    라우팅 키가 "quick.orange.rabbit"로 설정된 메시지가 두 대기열에 전달됩니다. 
    "lazy.orange.elephant"메시지도 양쪽 모두에 전달됩니다. 
    반면에 "quick.orange.fox"는 첫 번째 대기열로 이동하고 "lazy.brown.fox"는 두 번째 대기열로 이동합니다. 
    "lazy.pink.rabbit"은 두 개의 바인딩과 일치하더라도 두 번째 큐에 한 번만 전달됩니다. 
    "quick.brown.fox"는 바인딩과 일치하지 않으므로 버려집니다.